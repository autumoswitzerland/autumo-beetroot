/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ch.autumo.beetroot.utils;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ServiceLoader;

import org.apache.commons.dbutils.ColumnHandler;
import org.apache.commons.dbutils.PropertyHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.autumo.beetroot.Entity;

/**
 * This bean processor operates with bean fields that hold information of
 * beetRoot model beans with database annotation information generated by
 * the beetRoot PLANT generator. There's no interpretation how table names
 * are mapped to property names, it is simply defined by the 'Column'-
 * annotation.
 *
 * We do not allow e.g. Java property camel case to database snake case
 * conversion, because if we save or update objects, we don't know what
 * database columns are present in the database; we would first have to
 * get table meta data from the database and update the model with it,
 * but this is inefficient! The method {@link DB#updateModel(Entity, Map)}
 * would allow to update the model with database meta data, but for
 * efficiency reasons {@link Beans#updateModel(Entity, Map)} us used.
 * 
 * Originally from the 1.8 version of apache's common-dbutils:
 * https://github.com/apache/commons-dbutils/blob/master/src/main/java/org/apache/commons/dbutils/BeanProcessor.java
 * 
 * <p>
 * {@code BeanProcessor} matches column names to bean property names and
 * converts {@code ResultSet} columns into objects for those bean properties.
 * Subclasses should override the methods in the processing chain to customize
 * behavior.
 * </p>
 *
 * <p>
 * This class is thread-safe.
 * </p>
 *
 * @since 1.1
 */
public class BeanProcessor {

	private static final Logger LOG = LoggerFactory.getLogger(BeanProcessor.class.getName());
	
	/**
	 * Special array value used by {@code mapColumnsToProperties} that indicates
	 * there is no bean property that matches a column from a {@code ResultSet}.
	 */
	protected static final int PROPERTY_NOT_FOUND = -1;

    private static final List<ColumnHandler<?>> COLUMN_HANDLERS = new ArrayList<>();
    private static final List<PropertyHandler> PROPERTY_HANDLERS = new ArrayList<>();
    
	/**
	 * Set a bean's primitive properties to these defaults when SQL NULL is
	 * returned. These are the same as the defaults that ResultSet get* methods
	 * return in the event of a NULL column.
	 */
	private static final Map<Class<?>, Object> PRIMITIV_TYPES = new HashMap<>();
	static {
		PRIMITIV_TYPES.put(Integer.TYPE, Integer.valueOf(0));
		PRIMITIV_TYPES.put(Short.TYPE, Short.valueOf((short) 0));
		PRIMITIV_TYPES.put(Byte.TYPE, Byte.valueOf((byte) 0));
		PRIMITIV_TYPES.put(Float.TYPE, Float.valueOf(0f));
		PRIMITIV_TYPES.put(Double.TYPE, Double.valueOf(0d));
		PRIMITIV_TYPES.put(Long.TYPE, Long.valueOf(0L));
		PRIMITIV_TYPES.put(Boolean.TYPE, Boolean.FALSE);
		PRIMITIV_TYPES.put(Character.TYPE, Character.valueOf((char) 0));
		// Use a ServiceLoader to find implementations
        ServiceLoader.load(ColumnHandler.class).forEach(COLUMN_HANDLERS::add);
        // Use a ServiceLoader to find implementations
        ServiceLoader.load(PropertyHandler.class).forEach(PROPERTY_HANDLERS::add);		
	}

	/**
	 * Constructor for BeanProcessor.
	 */
	public BeanProcessor() {
	}

	/**
	 * Convert a {@code ResultSet} row into a JavaBean. This implementation uses
	 * reflection and {@code BeanInfo} classes to match column names to bean
	 * property names. Properties are matched to columns based on several factors:
	 * &lt;br/&gt; &lt;ol&gt; &lt;li&gt; The class has a writable property with the
	 * same name as a column. The name comparison is case insensitive. &lt;/li&gt;
	 *
	 * &lt;li&gt; The column type can be converted to the property's set method
	 * parameter type with a ResultSet.get* method. If the conversion fails (ie. the
	 * property was an int and the column was a Timestamp) an SQLException is
	 * thrown. &lt;/li&gt; &lt;/ol&gt;
	 *
	 * &lt;p&gt; Primitive bean properties are set to their defaults when SQL NULL
	 * is returned from the {@code ResultSet}. Numeric fields are set to 0 and
	 * booleans are set to false. Object bean properties are set to {@code null}
	 * when SQL NULL is returned. This is the same behavior as the {@code ResultSet}
	 * get* methods. &lt;/p&gt;
	 * 
	 * @param rs ResultSet that supplies the bean data
	 * @param type Class from which to create the bean instance
	 * @throws SQLException if a database access error occurs
	 * @return the newly created bean
	 */
	public Entity toBean(ResultSet rs, Class<?> type) throws SQLException {
		final Entity entity = (Entity) this.newInstance(type);
		return this.populateBean(rs, entity);
	}

	/**
	 * Convert a {@code ResultSet} into a {@code List} of JavaBeans. This
	 * implementation uses reflection and {@code BeanInfo} classes to match column
	 * names to bean property names. Properties are matched to columns based on
	 * several factors: &lt;br/&gt; &lt;ol&gt; &lt;li&gt; The class has a writable
	 * property with the same name as a column. The name comparison is case
	 * insensitive. &lt;/li&gt;
	 *
	 * &lt;li&gt; The column type can be converted to the property's set method
	 * parameter type with a ResultSet.get* method. If the conversion fails (ie. the
	 * property was an int and the column was a Timestamp) an SQLException is
	 * thrown. &lt;/li&gt; &lt;/ol&gt;
	 *
	 * <p>
	 * Primitive bean properties are set to their defaults when SQL NULL is returned
	 * from the {@code ResultSet}. Numeric fields are set to 0 and booleans are set
	 * to false. Object bean properties are set to {@code null} when SQL NULL is
	 * returned. This is the same behavior as the {@code ResultSet} get* methods.
	 * &lt;/p&gt;
	 * 
	 * @param rs ResultSet that supplies the bean data
	 * @param type Class from which to create the bean instance
	 * @throws SQLException if a database access error occurs
	 * @return the newly created List of beans
	 */
	public List<Entity> toBeanList(ResultSet rs, Class<?> type) throws SQLException {
		final List<Entity> results = new ArrayList<>();
		if (!rs.next()) {
			return results;
		}
		final BeanField beanfields[] = Beans.getBeanFieldsAsArray(type);
		final ResultSetMetaData rsmd = rs.getMetaData();
		final int[] columnToProperty = this.mapColumnsToProperties(rsmd, beanfields);
		do {
			results.add(this.createBean(rs, type, beanfields, columnToProperty));
		} while (rs.next());
		return results;
	}

	/**
	 * Creates a new object and initializes its fields from the ResultSet.
	 * 
	 * @param rs The result set.
	 * @param type The bean type (the return type of the object).
	 * @param beanFields The bean fields.
	 * @param columnToProperty The column indices in the result set.
	 * @return An initialized object.
	 * @throws SQLException if a database error occurs.
	 */
	private Entity createBean(ResultSet rs, Class<?> type, BeanField beanFields[], int columnToProperty[]) throws SQLException {
		final Entity entity = (Entity) this.newInstance(type);
		return populateBean(rs, entity, beanFields, columnToProperty);
	}

	/**
	 * Initializes the fields of the provided bean from the ResultSet.
	 * 
	 * @param rs The result set.
	 * @param entity The bean to be populated.
	 * @return An initialized object.
	 * @throws SQLException if a database error occurs.
	 */
	public Entity populateBean(ResultSet rs, Entity entity) throws SQLException {
		final ResultSetMetaData rsmd = rs.getMetaData();
		final BeanField beanfields[] = Beans.getBeanFieldsAsArray(entity.getClass());
		final int[] columnToProperty = this.mapColumnsToProperties(rsmd, beanfields);
		return populateBean(rs, entity, beanfields, columnToProperty);
	}

	/**
	 * This method populates a bean from the ResultSet based upon the underlying
	 * meta-data.
	 *
	 * @param rs The result set.
	 * @param entity The bean to be populated.
	 * @param beanFields The bean fields.
	 * @param columnToProperty The column indices in the result set.
	 * @return An initialized object.
	 * @throws SQLException if a database error occurs.
	 */
	private Entity populateBean(ResultSet rs, Entity entity, BeanField beanFields[], int columnToProperty[]) throws SQLException {
		for (int i = 1; i < columnToProperty.length; i++) {
			if (columnToProperty[i] == PROPERTY_NOT_FOUND) {
				continue;
			}
			final BeanField beanField = beanFields[columnToProperty[i]];
			final Class<?> propType = beanField.getType();
			Object value = null;
			if (propType != null) {
				value = this.processColumn(rs, i, propType);
				if (value == null && propType.isPrimitive()) {
					value = PRIMITIV_TYPES.get(propType);
				}
			}
			this.callSetter(entity, beanField, value);
		}
		return entity;
	}

	/**
	 * Calls the setter method on the target object for the given property. If no
	 * setter method exists for the property, this method does nothing.
	 * 
	 * @param target The object to set the property on.
	 * @param prop The property to set.
	 * @param value The value to pass into the setter.
	 * @throws SQLException if an error occurs setting the property.
	 */
	private void callSetter(Object target, BeanField beanField, Object value) throws SQLException {
		final Method setter = getWriteMethod(target, beanField, value);
		if (setter == null || setter.getParameterTypes().length != 1)
			return;
		try {
			final Class<?> firstParam = setter.getParameterTypes()[0];
            for (final PropertyHandler handler : PROPERTY_HANDLERS) {
                if (handler.match(firstParam, value)) {
                    value = handler.apply(firstParam, value);
                    break;
                }
            }			
			// Don't call setter if the value object isn't the right type
			if (!this.isCompatibleType(value, firstParam)) {
				throw new SQLException("Cannot set " + beanField.getBeanName() + ": incompatible types, cannot convert "
						+ value.getClass().getName() + " to " + firstParam.getName());
				// value cannot be null here because isCompatibleType allows null
			}
			setter.invoke(target, value);
		} catch (final IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {
			throw new SQLException("Cannot set " + beanField.getBeanName() + ": " + e.getMessage());
		}
	}

	/**
	 * ResultSet.getObject() returns an Integer object for an INT column. The setter
	 * method for the property might take an Integer or a primitive int. This method
	 * returns true if the value can be successfully passed into the setter method.
	 * Remember, Method.invoke() handles the unwrapping of Integer into an int.
	 *
	 * @param value The value to be passed into the setter method.
	 * @param type  The setter's parameter type (non-null)
	 * @return boolean True if the value is compatible (null => true)
	 */
	private boolean isCompatibleType(Object value, Class<?> type) {
		// Do object check first, then primitives
		if (value == null || type.isInstance(value) || matchesPrimitive(type, value.getClass())) {
			return true;
		}
		return false;
	}

	/**
	 * Check whether a value is of the same primitive type as {@code targetType}.
	 *
	 * @param targetType The primitive type to target.
	 * @param valueType The value to match to the primitive type.
	 * @return Whether {@code valueType} can be coerced (e.g. autoboxed) into
	 *         {@code targetType}.
	 */
	private boolean matchesPrimitive(Class<?> targetType, Class<?> valueType) {
		if (!targetType.isPrimitive()) {
			return false;
		}
		try {
			// see if there is a "TYPE" field. This is present for primitive wrappers.
			final Field typeField = valueType.getField("TYPE");
			final Object primitiveValueType = typeField.get(valueType);

			if (targetType == primitiveValueType) {
				return true;
			}
		} catch (final NoSuchFieldException | IllegalAccessException ignored) {
			// an inaccessible TYPE field is a good sign that we're not working with a
			// primitive wrapper.
			// nothing to do. we can't match for compatibility
		}
		return false;
	}

	/**
	 * Get the write method to use when setting {@code value} to the {@code target}.
	 *
	 * @param target Object where the write method will be called.
	 * @param beanField Bean field information.
	 * @param value The value that will be passed to the write method.
	 * @return The {@link java.lang.reflect.Method} to call on {@code target} to
	 *         write {@code value} or {@code null} if there is no suitable write
	 *         method.
	 */
	protected Method getWriteMethod(Object target, BeanField beanField, Object value) {
		final String beanName = beanField.getBeanName();
		final String methodName = "set" + beanName.substring(0, 1).toUpperCase() + beanName.substring(1, beanName.length());
		Method method = null;
		Class<?> clz = target.getClass();
		while (clz != null) {
			try {
				method = clz.getDeclaredMethod(methodName, beanField.getType());
				clz = null;
			} catch (Exception e) {
				clz = clz.getSuperclass();
			}		
		}
		if (method == null) {
			LOG.error("Method '"+methodName+"' not found in class '"+target.getClass().getName()+"! Your bean is corrupted!");
			throw new RuntimeException("Method '"+methodName+"' not found in class' "+target.getClass().getName()+"! Your bean is corrupted!"); // not good!
		}
		return method;
	}

	/**
	 * Factory method that returns a new instance of the given Class. This is called
	 * at the start of the bean creation process and may be overridden to provide
	 * custom behavior like returning a cached bean instance.
	 * 
	 * @param <T> The type of object to create
	 * @param c   The Class to create an object from.
	 * @return A newly created object of the Class.
	 * @throws SQLException if creation failed.
	 */
	protected <T> T newInstance(Class<T> c) throws SQLException {
		try {
			return c.getDeclaredConstructor().newInstance();
		} catch (final IllegalAccessException | InstantiationException | InvocationTargetException
				| NoSuchMethodException e) {
			throw new SQLException("Cannot create " + c.getName() + ": " + e.getMessage());
		}
	}
	
	/**
	 * The positions in the returned array represent column numbers. The values
	 * stored at each position represent the index in the
	 * {@code BeanField[]} for the bean property that matches the column
	 * name. If no bean property was found for a column, the position is set to
	 * {@code PROPERTY_NOT_FOUND}.
	 *
	 * @param rsmd The {@code ResultSetMetaData} containing column information.
	 * @param beanFields The bean fields.
	 * @throws SQLException if a database access error occurs
	 * @return An int[] with column index to property index mappings. The 0th
	 *         element is meaningless because JDBC column indexing starts at 1.
	 */
	protected int[] mapColumnsToProperties(ResultSetMetaData rsmd, BeanField beanFields[])
			throws SQLException {

		final int cols = rsmd.getColumnCount();
		final int[] columnToProperty = new int[cols + 1];
		Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);

		for (int col = 1; col <= cols; col++) {
			
			String columnName = rsmd.getColumnLabel(col);
			if (null == columnName || 0 == columnName.length()) {
				columnName = rsmd.getColumnName(col);
			}
			
			// Map per bean fields that hold annotation information about DB columns!
			for (int i = 0; i < beanFields.length; i++) {
				final BeanField bf = beanFields[i];
				final String dbColumnName = bf.getDbName();
				if (columnName.equalsIgnoreCase(dbColumnName)) {
					columnToProperty[col] = i;
					break;
				}
			}
		}
		return columnToProperty;
	}
	
	/**
	 * The positions in the returned array represent column numbers. The values
	 * stored at each position represent the index in the
	 * {@code BeanField[]} for the bean property that matches the column
	 * name. If no bean property was found for a column, the position is set to
	 * {@code PROPERTY_NOT_FOUND}.
	 * 
	 * This method tries not only to map properties by bean fields, it also tries
	 * to map properties by comparing property names to table column names (snake- 
	 * to camel-case conversion) if no 'Column'-annotations are found!
	 *
	 * @param rsmd  The {@code ResultSetMetaData} containing column information.
	 * @param beanFields The bean fields.
	 * @throws SQLException if a database access error occurs
	 * @return An int[] with column index to property index mappings. The 0th
	 *         element is meaningless because JDBC column indexing starts at 1.
	 */
	protected int[] mapColumnsToPropertiesWithAllMethods(ResultSetMetaData rsmd, BeanField beanFields[])
			throws SQLException {

		final int cols = rsmd.getColumnCount();
		final int[] columnToProperty = new int[cols + 1];
		Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);

		for (int col = 1; col <= cols; col++) {
			
			String columnName = rsmd.getColumnLabel(col);
			if (null == columnName || 0 == columnName.length()) {
				columnName = rsmd.getColumnName(col);
			}
			columnName = columnName.toLowerCase();
			
			// Map per bean fields that hold annotation information about DB columns!
			for (int i = 0; i < beanFields.length; i++) {
				
				final BeanField bf = beanFields[i];
				final String dbColumnName = bf.getDbName();
				
				if (dbColumnName == null) { 
					// A. No Column annotation was present, that's OK
					// -> We must compare created bean names
					String beanName = bf.getBeanName(); // Let's investigate the bean name
					String createdBeanName = "";
					// We go from camel to snake case!
					if (columnName.contains("_")) {
						final String parts[] = columnName.split("_");
						for (int p = 0; p < parts.length; p++) {
							final String cp = parts[p];
							if (p > 0)
								createdBeanName += cp.substring(0, 1).toUpperCase() + cp.substring(1, cp.length());
							else
								createdBeanName += cp;
						}
					} else {
						beanName = columnName;
					}
					if (createdBeanName.equalsIgnoreCase(beanName)) {
						columnToProperty[col] = i;
						break;
					}
					
				} else {
					// B. Column annotation was present -> default case (annotations generated by PLANT)
					// --> We simply compare table names!
					if (columnName.equalsIgnoreCase(dbColumnName)) {
						columnToProperty[col] = i;
						break;
					}
				}
			}
		}
		return columnToProperty;
	}

	/**
	 * Convert a {@code ResultSet} column into an object. Simple implementations
	 * could just call {@code rs.getObject(index)} while more complex
	 * implementations could perform type manipulation to match the column's type to
	 * the bean property type.
	 *
	 * <p>
	 * This implementation calls the appropriate {@code ResultSet} getter method for
	 * the given property type to perform the type conversion. If the property type
	 * doesn't match one of the supported {@code ResultSet} types, {@code getObject}
	 * is called.
	 * </p>
	 *
	 * @param rs       The {@code ResultSet} currently being processed. It is
	 *                 positioned on a valid row before being passed into this
	 *                 method.
	 * @param index    The current column index being processed.
	 * @param propType The bean property type that this column needs to be converted
	 *                 into.
	 *
	 * @throws SQLException if a database access error occurs
	 *
	 * @return The object from the {@code ResultSet} at the given column index after
	 *         optional type processing or {@code null} if the column value was SQL
	 *         NULL.
	 */
	protected Object processColumn(ResultSet rs, int index, Class<?> propType) throws SQLException {
        Object retval = rs.getObject(index);
        if (!propType.isPrimitive() && retval == null) {
            return null;
        }
        for (final ColumnHandler<?> handler : COLUMN_HANDLERS) {
            if (handler.match(propType)) {
                retval = handler.apply(rs, index);
                break;
            }
        }
        return retval;
	}

}
